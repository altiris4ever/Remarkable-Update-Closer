<#
.SYNOPSIS
A PowerShell script to monitor and close the "Software Update" dialog generated by the Remarkable application.

.DESCRIPTION
This script uses the Windows API (via User32.dll) to enumerate all open windows, match their titles to a specified partial title, 
and send a WM_CLOSE message to close matching dialog boxes. It targets only windows belonging to a specific process (e.g., "remarkable.exe").

The script includes:
- An aggressive monitoring phase to quickly respond when the dialog first appears.
- A CPU-efficient monitoring phase with gradually increasing sleep intervals when no dialog is detected.
- Optional logging to track when windows are detected and closed.

.PARAMETER PartialTitle
A partial string to match the window title. For example, "Software Update".

.PARAMETER ProcessName
The name of the process owning the target window. For example, "remarkable".

.PARAMETER Logging
(Optional) Enable or disable logging of closed windows. Defaults to $false.

.NOTES
Author: [GitHub Username altiris4ever]
Version: 1.0
Date: [30.1.25]
License: MIT

.EXAMPLE
Run the script to monitor and close "Software Update" windows for the "remarkable.exe" process:
    powershell.exe -ExecutionPolicy Bypass -File "CloseRemarkableUpdate.ps1"

.EXAMPLE
Run the script with logging enabled:
    powershell.exe -ExecutionPolicy Bypass -File "CloseRemarkableUpdate.ps1" -Logging $true

#>

Add-Type @"
using System;
using System.Runtime.InteropServices;
using System.Text;

public class User32 {
    public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    public const uint WM_CLOSE = 0x0010; // Windows message for closing a window
}
"@

# Function to find and close a dialog window based on its title and the owning process name
function Close-DialogWindow {
    param (
        [string]$PartialTitle,      # Part of the window's title to match
        [string]$ProcessName,       # Name of the process owning the window
        [bool]$Logging = $false     # Whether to enable logging of closed windows
    )

    $found = $false # Tracks if a matching window was found

    # Callback function executed for every window enumerated by EnumWindows
    $callback = {
        param ($hWnd, $lParam)

        # Retrieve the title of the current window
        $titleBuilder = New-Object System.Text.StringBuilder 256
        [User32]::GetWindowText($hWnd, $titleBuilder, $titleBuilder.Capacity) | Out-Null
        $title = $titleBuilder.ToString()

        # Check if the window's title matches the specified partial title
        if ($title -like "*$PartialTitle*") {
            $processId = [int]0
            [User32]::GetWindowThreadProcessId($hWnd, [ref]$processId) | Out-Null

            # Retrieve the process owning the window
            $process = Get-Process -Id $processId -ErrorAction SilentlyContinue
            if ($process -and $process.ProcessName -eq $ProcessName) {
                # Send a WM_CLOSE message to the window to close it
                [User32]::PostMessage($hWnd, [User32]::WM_CLOSE, [IntPtr]::Zero, [IntPtr]::Zero) | Out-Null
                $logMessage = "Closed window with title: $title from process: $ProcessName"

                # Log the action if logging is enabled
                if ($Logging) { Add-Content -Path "log.txt" -Value $logMessage }
                #Write-Host $logMessage
                $found = $true
            }
        }

        return $true # Continue enumerating other windows
    }

    # Start enumerating all open windows
    $enumProc = [User32+EnumWindowsProc]$callback
    [User32]::EnumWindows($enumProc, [IntPtr]::Zero) | Out-Null

    return $found # Return whether a matching window was found
}

# Configuration variables
$WindowPartialTitle = "Software Update" # Part of the title of the dialog to close
$TargetProcessName = "remarkable"       # Name of the target process
$LoggingEnabled = $false                # Set logging to disabled by default

# Aggressive checking duration (in milliseconds)
$initialCheckDuration = 60000 # 60 seconds
$startTime = [DateTime]::Now  # Start time for the aggressive checking period
$sleepTime = 100              # Initial frequent checking (100ms intervals)
$maxSleepTime = 2000          # Less frequent checks after the aggressive period (every 2 seconds)

# Main loop for monitoring and handling windows
while ($true) {
    $elapsedTime = ([DateTime]::Now - $startTime).TotalMilliseconds

    # Check if the target process is still running
    $remarkableProcess = Get-Process -Name $TargetProcessName -ErrorAction SilentlyContinue
    if (-not $remarkableProcess) {
        exit # Exit the script if the target process is no longer running
    }

    if ($elapsedTime -lt $initialCheckDuration) {
        # During the aggressive checking period, frequently check for the dialog window
        $windowActive = Close-DialogWindow -PartialTitle $WindowPartialTitle -ProcessName $TargetProcessName -Logging $LoggingEnabled
        if ($windowActive) {
            # Reset the start time to extend the aggressive checking period
            $startTime = [DateTime]::Now
            $sleepTime = 100 # Continue aggressive checking
        } else {
            $sleepTime = [math]::Min($sleepTime * 2, $maxSleepTime) # Gradually increase sleep time
        }
    } else {
        # After the aggressive period, check less frequently
        $windowActive = Close-DialogWindow -PartialTitle $WindowPartialTitle -ProcessName $TargetProcessName -Logging $LoggingEnabled
        if ($windowActive) {
            # Return to aggressive checking if a window is found
            $startTime = [DateTime]::Now
            $sleepTime = 100 # Reset to aggressive checking
        } else {
            $sleepTime = [math]::Min($sleepTime * 2, $maxSleepTime) # Gradually increase sleep time
        }
    }

    Start-Sleep -Milliseconds $sleepTime # Pause for the determined sleep interval
}

